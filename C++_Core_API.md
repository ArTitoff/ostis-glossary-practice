> **Примечание:** Это верно только для версий sc-machine, которые >= 0.10.0.

API предоставляет основные функциональные возможности для создания, извлечения и удаления sc-элементов в sc-памяти. Эта sc-память предназначена для представления знаний в структурированном и графовом формате.

Sc-память состоит из sc-элементов. Sc-элементы могут быть сгруппированы в sc-конструкции (семантические графы или графы знаний). Среди sc-элементов есть sc-узлы, sc-связи и sc-коннекторы между ними. Все sc-элементы имеют синтаксический и семантический sc-типы. Sc-коннекторы делятся на неориентированные sc-коннекторы (sc-ребра) и ориентированные sc-коннекторы (sc-дуги). Каждый sc-коннектор имеет исходный и целевой sc-элементы. Эти sc-элементы могут быть sc-узлами, sc-ссылками или sc-коннекторами. Все эти атрибуты sc-элементов и структур sc-элементов скрыты от пользователя, но вы можете получить эти функции, используя этот API.

> **Примечание:** Все методы API являются потокобезопасными.
 
> **Примечание:** Чтобы подключить этот API, укажите ```#include <sc-memory/sc_memory.hpp>``` в вашем исходный файле hpp.

⚠️ **Предупреждение:** Объекты класса ```ScMemoryContext``` являются подвижными, но не копируемыми.

## ScAddr

Каждый sc-элемент имеет sc-адрес, с помощью которого вы можете получить информацию об этом sc-элементе.

```
...
ScAddr elementAddr1 = // некоторый вызов метода API 1
ScAddr elementAddr2 = // некоторый вызов метода API 2
// Сравниваем sc-адреса
bool const isAddrsEqual = elementAddr1 == elementAddr2;
```
## ScMemoryContext

Это класс, предоставляющий все методы API для создания, управления, извлечения и удаления sc-элементов в sc-памяти. Он относится к набору атрибутов и прав некоторого субъекта действия в sc-памяти (пользователя или агента), которые используются во время выполнения методов API.

```
...
// Для создания такого контекста используйте конструктор ScMemoryContext.
ScMemoryContext context;
// После этого вы можете использовать этот объект для вызова любых методов API.
```
## GenerateNode

Для создания sc-узлов вы можете использовать метод GenerateNode, для создания sc-ссылок - метод GenerateLink, для создания sc-коннекторов между ними - метод GenerateConnector. Все эти методы проверяют переданные sc-типы. Если указанный sc-тип недействителен, то метод выдает исключение utils::ExceptionInvalidParams с описанием этой ошибки.

```
...
// Сгенерировать sc-узел и получить его sc-адрес в sc-памяти.
ScAddr const & nodeAddr = context.GenerateNode(ScType::ConstNode);
// Указанный sc-тип должен быть одним из типов ScType::...Node... type.
```

## GenerateLink
```
...
// Сгенерируйте sc-ссылку и получите ее sc-адрес в sc-памяти.
ScAddr const & linkAddr = context.GenerateLink(ScType::ConstNodeLink);
// Указанный sc-тип должен быть одним из типов ScType::...NodeLink... type.
```

> **Примечание:** Теперь все sc-ссылки не являются sc-узлами. Это может быть исправлено в последующих версиях sc-machine. Но вы можете использовать метод ```GenerateNode``` для создания sc-ссылок.

## GenerateConnector
```
...
// Сгенерировать sc-дугу между sc-узлом и sc-каналом и получить sc-адрес в 
// sc-памяти этого узла.
ScAddr const & arcAddr = context.GenerateConnector(
    ScType::ConstPermPosArc, nodeAddr, linkAddr);
// Указанный sc-тип должен быть одним из типовScType::Edge... type.
```

Если указанные sc-адреса исходного и целевого sc-элементов недействительны, то метод выдает исключение ```utils::ExceptionInvalidParams``` с описанием того, что некоторые из указанных sc-адресов недействительны.

> **Примечание:** Хотя этот метод вызван неправильно и может ввести в заблуждение, но с его помощью вы можете создать любые sc-коннекторы.

## IsElement

Чтобы проверить, является ли указанный sc-адрес действительным в sc-памяти, вы можете использовать метод ```IsElement```. Действительный sc-адрес относится к sc-адресу, который существует в sc-памяти и который соответствует некоторому sc-элементу в ней.

```
...
// Проверьте, все ли созданные sc-элементы допустимы.
bool const isNodeValid = context.IsElement(nodeAddr);
bool const isLinkValid = context.IsElement(linkAddr);
bool const isArcValid = context.IsElement(arcAddr);
```

> **Примечание:** Вы можете проверить, не является ли указанный sc-адрес пустым, вызвав из этого sc-адреса объектный метод ```IsValid```. Но предпочтительнее использовать ```IsElement```, он проверяет, существует ли указанный sc-адрес и действителен ли он в sc-памяти.

## GetElementType
При необходимости вы можете получить типы sc-элементов по их sc-адресам. Если указанный sc-адрес неверен, то метод выдает исключение ```utils::ExceptionInvalidParams``` с описанием того, что указанный sc-адрес неверен.

```
...
// Получить созданные sc-элементы sc-типов.
ScType const & nodeType = context.GetElementType(nodeAddr);
ScType const & linkType = context.GetElementType(linkAddr);
ScType const & arcType = context.GetElementType(arcAddr);
```
## SetElementSubtype

Вы можете изменить семантический sc-тип sc-элемента. Используйте метод ```SetElementSubtype``` и укажите семантический sc-тип для синтаксического sc-типа sc-элемента.

```
...
// Сгенерировать sc-узел и получить его sc-адрес в sc-памяти.
ScAddr const & nodeAddr = context.GenerateNode(ScType::Node);
bool const isSubtypeElementChanged 
    = context.SetElementSubtype(node, ScType::ConstNode);
// Значение `isSubtypeElementChanged` должно быть равно `true`.
```
> **Примечание:** Не используйте этот метод для изменения синтаксического sc-типа для sc-элемента. Это вводит в заблуждение.

## GetConnectorIncidentElements

Чтобы получить инцидентные (исходные и целевые) sc-элементы, вы можете использовать методы ```GetConnectorIncidentElements```, ```GetArcSourceElement``` и ```GetArcTargetElement```. Если указанный sc-адрес недействителен, то эти методы выдадут исключение utils::ExceptionInvalidParams с описанием того, что указанный sc-адрес sc-коннектора недействителен.

```
...
// Получите инцидентные sc-элементы для sc-дуги.
auto const [sourceAddr, targetAddr] 
  = context.GetConnectorIncidentElements(arcAddr);
// sc-адрес `sourceAddr` должен быть равен sc-адресу `nodeAddr` 
// и sc-адрес `targetAddr` должен быть равен sc-адресу `linkAddr`.
...
// Или получите инцидентные источник и цель sc-дуги отдельно.
ScAddr const & sourceAddr = context.GetArcSourceElement(arcAddr);
// sc-адрес `sourceAddr` должен быть равен sc-адресу `nodeAddr`.
ScAddr const & targetAddr = context.GetArcTargetElement(arcAddr);
// sc-адрес `targetAddr` должен быть равен sc-адресу `linkAddr`.
```
Чтобы найти ранее созданные sc-конструкции, вы можете использовать 3-элементные sc-итераторы и 5-элементные sc-итераторы из C++ API. На рисунке ниже показана нумерация sc-элементов в 3-элементных (слева) и 5-элементных (справа) sc-итераторах.

### Нумерация элементов итераторов

![image](https://github.com/user-attachments/assets/2b375bc6-02cb-472e-b7a5-88ef526a03d7)

Для них обоих у вас есть два подхода. Первый подход заключается в использовании простого цикла while. Он подходит, когда вам нужно разорвать этот цикл в зависимости от логики:

## ScIterator3

```
...
// Создать sc-итератор для поиска всех sc-адресов sc-элементов 
// с неизвестным sc-типом, принадлежащим sc-набору, с sc-адресом `setAddr`.
ScIterator3Ptr it3 = context.CreateIterator3(
    setAddr,
    ScType::ConstPermPosArc,
    ScType::Unknown);
// Используйте it3->Next(), чтобы перейти к следующей подходящей
// по условию sc-конструкции.
while (it3->Next())
{
// Чтобы получить значения, используйте `it3->Get(index)`,
// где index в диапазоне [0; 2]. 
 // Он возвращает `true`, если найдена следующая подходящая конструкция,
// в противном случае `false`.
 ... // Напишите свой код для обработки найденной sc-конструкции.
}
```
